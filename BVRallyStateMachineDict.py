# /// script
# requires-python = ">=3.9"
# dependencies = []
# ///
"""Beach Volleyball Rally State Machine - Dictionary Representation

A functional approach to modeling beach volleyball rally states using a dictionary-based
representation. This module provides a simplified state machine structure where states
are represented as strings and transitions as tuples.

Key Features:
- Dictionary-based state representation for easy lookup
- Functional programming style with immutable data structures
- Comprehensive error handling and validation
- Type hints throughout for better code clarity
- Self-contained with no external dependencies
- Detailed documentation with examples

Dictionary Structure:
- Key: String representing the rally state
- Value: Tuple of (to_rally_state_string, probability, action_type)

Team Convention:
- s_ prefix states: Team A (serving team) actions
- r_ prefix states: Team B (receiving team) actions

Author: Generated by AI Assistant
Date: July 11, 2025
Python Version: 3.9+
"""

from typing import Dict, List, Tuple, Optional, Set
from decimal import Decimal
from dataclasses import dataclass
from enum import Enum


class ActionType(str, Enum):
    """Types of actions that can occur in a rally."""
    
    SERVE = "serve"
    RECEPTION = "reception"
    SET = "set"
    ATTACK = "attack"
    DIG = "dig"
    BLOCK = "block"
    TRANSITION = "transition"


# Type alias for state transition tuple
StateTransitionTuple = Tuple[str, Decimal, ActionType]


@dataclass
class RallyStateMachine:
    """Dictionary-based rally state machine for beach volleyball.
    
    This class encapsulates the state machine logic using a dictionary representation
    where each state maps to possible transitions with their probabilities and action types.
    
    Attributes:
        transitions: Dictionary mapping state strings to lists of transition tuples
        terminal_states: Set of state strings that end the rally
        initial_state: The starting state for a new rally
    """
    
    transitions: Dict[str, List[StateTransitionTuple]]
    terminal_states: Set[str]
    initial_state: str = "s_serve_ready"
    
    def get_next_states(self, current_state: str) -> List[StateTransitionTuple]:
        """Get possible next states from current state.
        
        Args:
            current_state: Current rally state as string
            
        Returns:
            List of transition tuples (next_state, probability, action_type)
            
        Raises:
            ValueError: If current_state is not in the state machine
        """
        if current_state not in self.transitions:
            raise ValueError(f"Invalid state: {current_state}")
        
        return self.transitions[current_state]
    
    def is_terminal_state(self, state: str) -> bool:
        """Check if a state is terminal (ends the rally).
        
        Args:
            state: State string to check
            
        Returns:
            True if state is terminal, False otherwise
        """
        return state in self.terminal_states
    
    def is_valid_transition(self, from_state: str, to_state: str) -> bool:
        """Check if a transition between states is valid.
        
        Args:
            from_state: Starting state
            to_state: Destination state
            
        Returns:
            True if transition is valid, False otherwise
        """
        if from_state not in self.transitions:
            return False
        
        valid_next_states = [transition[0] for transition in self.transitions[from_state]]
        return to_state in valid_next_states
    
    def get_acting_team(self, state: str) -> str:
        """Get which team is acting in the given state.
        
        Args:
            state: Rally state string
            
        Returns:
            'serving' if serving team acts, 'receiving' if receiving team acts,
            'terminal' if rally is over
        """
        if state.startswith('s_'):
            return 'serving'
        elif state.startswith('r_'):
            return 'receiving'
        else:
            return 'terminal'
    
    def get_all_states(self) -> Set[str]:
        """Get all states in the state machine.
        
        Returns:
            Set of all state strings
        """
        all_states = set(self.transitions.keys())
        all_states.update(self.terminal_states)
        return all_states
    
    def get_continuation_states(self) -> Set[str]:
        """Get all non-terminal states.
        
        Returns:
            Set of continuation state strings
        """
        return self.get_all_states() - self.terminal_states
    
    def validate_probabilities(self) -> bool:
        """Validate that all transition probabilities sum to 1.0 for each state.
        
        Returns:
            True if all probabilities are valid, False otherwise
        """
        for state, transitions in self.transitions.items():
            if not transitions:  # Skip states with no transitions
                continue
                
            total_probability = sum(transition[1] for transition in transitions)
            if abs(total_probability - Decimal("1.0")) > Decimal("0.001"):
                print(f"Warning: State {state} probabilities sum to {total_probability}, not 1.0")
                return False
        
        return True


def create_state_machine_from_teams(
    team_serving_probs: Dict[str, List[Tuple[str, Decimal]]], 
    team_receiving_probs: Dict[str, List[Tuple[str, Decimal]]]
) -> RallyStateMachine:
    """Create a custom state machine from team-specific probability dictionaries.
    
    This function creates a rally state machine using custom probabilities for each team.
    The probabilities are provided as dictionaries where each state maps to a list of
    possible transitions with their probabilities.
    
    Args:
        team_serving_probs: Dictionary of serving team state transitions.
            Format: {"state_name": [("next_state", Decimal("probability")), ...]}
        team_receiving_probs: Dictionary of receiving team state transitions.
            Format: {"state_name": [("next_state", Decimal("probability")), ...]}
    
    Returns:
        RallyStateMachine instance with custom team probabilities
        
    Raises:
        ValueError: If probability dictionaries are malformed or probabilities don't sum to 1.0
        
    Example:
        >>> serving_probs = {
        ...     "s_serve_ready": [
        ...         ("s_serve_ace", Decimal("0.08")),
        ...         ("s_serve_error", Decimal("0.12")),
        ...         ("s_serve_in_play", Decimal("0.80"))
        ...     ]
        ... }
        >>> receiving_probs = {
        ...     "r_reception_perfect": [
        ...         ("r_set_perfect", Decimal("0.80")),
        ...         ("r_set_good", Decimal("0.15")),
        ...         ("r_set_error", Decimal("0.05"))
        ...     ]
        ... }
        >>> sm = create_state_machine_from_teams(serving_probs, receiving_probs)
    """
    # Start with the default state machine structure
    default_sm = create_beach_volleyball_state_machine()
    
    # Create a copy of the default transitions
    custom_transitions: Dict[str, List[StateTransitionTuple]] = {}
    
    # Helper function to infer action type from state name
    def infer_action_type(state_name: str) -> ActionType:
        """Infer the action type from the state name."""
        if 'serve' in state_name:
            return ActionType.SERVE
        elif 'reception' in state_name:
            return ActionType.RECEPTION
        elif 'set' in state_name:
            return ActionType.SET
        elif 'attack' in state_name:
            return ActionType.ATTACK
        elif 'dig' in state_name:
            return ActionType.DIG
        elif 'block' in state_name:
            return ActionType.BLOCK
        elif 'transition' in state_name:
            return ActionType.TRANSITION
        else:
            return ActionType.TRANSITION  # Default fallback
    
    # Helper function to validate probabilities sum to 1.0
    def validate_state_probabilities(state: str, transitions: List[Tuple[str, Decimal]]) -> None:
        """Validate that probabilities for a state sum to 1.0."""
        total_prob = sum(prob for _, prob in transitions)
        if abs(total_prob - Decimal("1.0")) > Decimal("0.001"):
            raise ValueError(
                f"Probabilities for state '{state}' sum to {total_prob}, not 1.0. "
                f"Transitions: {transitions}"
            )
    
    # Process serving team probabilities
    for state, prob_transitions in team_serving_probs.items():
        if not state.startswith('s_'):
            raise ValueError(f"Serving team state '{state}' must start with 's_'")
        
        # Validate probabilities
        validate_state_probabilities(state, prob_transitions)
        
        # Convert to StateTransitionTuple format
        state_transitions = []
        for next_state, probability in prob_transitions:
            action_type = infer_action_type(next_state)
            state_transitions.append((next_state, probability, action_type))
        
        custom_transitions[state] = state_transitions
    
    # Process receiving team probabilities
    for state, prob_transitions in team_receiving_probs.items():
        if not state.startswith('r_'):
            raise ValueError(f"Receiving team state '{state}' must start with 'r_'")
        
        # Validate probabilities
        validate_state_probabilities(state, prob_transitions)
        
        # Convert to StateTransitionTuple format
        state_transitions = []
        for next_state, probability in prob_transitions:
            action_type = infer_action_type(next_state)
            state_transitions.append((next_state, probability, action_type))
        
        custom_transitions[state] = state_transitions
    
    # For any states not provided in custom dictionaries, use default probabilities
    for state, transitions in default_sm.transitions.items():
        if state not in custom_transitions:
            custom_transitions[state] = transitions
    
    # Verify that all referenced states in transitions exist
    all_referenced_states = set()
    for state, transitions in custom_transitions.items():
        all_referenced_states.add(state)
        for next_state, _, _ in transitions:
            all_referenced_states.add(next_state)
    
    # Check for missing transition definitions
    missing_states = []
    for state in all_referenced_states:
        if (state not in custom_transitions and 
            state not in default_sm.terminal_states and 
            state not in default_sm.transitions):
            missing_states.append(state)
    
    if missing_states:
        raise ValueError(
            f"Referenced states missing transition definitions: {missing_states}. "
            f"These states are referenced in transitions but have no outgoing transitions defined."
        )
    
    return RallyStateMachine(
        transitions=custom_transitions,
        terminal_states=default_sm.terminal_states,
        initial_state=default_sm.initial_state
    )


def get_common_state_templates() -> Dict[str, Dict[str, List[Tuple[str, Decimal]]]]:
    """Get common probability templates for different team skill levels.
    
    This function provides pre-defined probability templates that can be used as starting
    points for creating custom state machines. The templates represent different skill levels
    and playing styles.
    
    Returns:
        Dictionary with template names as keys and probability dictionaries as values
        
    Example:
        >>> templates = get_common_state_templates()
        >>> elite_serving = templates["elite_serving"]
        >>> novice_receiving = templates["novice_receiving"]
        >>> sm = create_state_machine_from_teams(elite_serving, novice_receiving)
    """
    
    templates = {
        # Elite level serving team - high ace rate, low error rate
        "elite_serving": {
            "s_serve_ready": [
                ("s_serve_ace", Decimal("0.12")),      # High ace rate
                ("s_serve_error", Decimal("0.05")),    # Low error rate
                ("s_serve_in_play", Decimal("0.83"))
            ],
            "s_set_perfect": [
                ("s_attack_kill", Decimal("0.45")),    # Very high kill rate
                ("s_attack_in_play", Decimal("0.40")),
                ("s_attack_error", Decimal("0.05")),   # Low error rate
                ("s_attack_blocked", Decimal("0.10"))
            ],
            "s_set_good": [
                ("s_attack_kill", Decimal("0.35")),    # High kill rate
                ("s_attack_in_play", Decimal("0.50")),
                ("s_attack_error", Decimal("0.05")),
                ("s_attack_blocked", Decimal("0.10"))
            ]
        },
        
        # Elite level receiving team - consistent and powerful
        "elite_receiving": {
            "r_reception_perfect": [
                ("r_set_perfect", Decimal("0.85")),    # Very high perfect set rate
                ("r_set_good", Decimal("0.12")),
                ("r_set_error", Decimal("0.03"))       # Very low error rate
            ],
            "r_reception_good": [
                ("r_set_perfect", Decimal("0.55")),    # Good conversion to perfect sets
                ("r_set_good", Decimal("0.35")),
                ("r_set_poor", Decimal("0.07")),
                ("r_set_error", Decimal("0.03"))
            ],
            "r_set_perfect": [
                ("r_attack_kill", Decimal("0.45")),    # Very high kill rate
                ("r_attack_in_play", Decimal("0.40")),
                ("r_attack_error", Decimal("0.05")),
                ("r_attack_blocked", Decimal("0.10"))
            ]
        },
        
        # Novice serving team - lower skill, higher errors
        "novice_serving": {
            "s_serve_ready": [
                ("s_serve_ace", Decimal("0.02")),      # Low ace rate
                ("s_serve_error", Decimal("0.18")),    # High error rate
                ("s_serve_in_play", Decimal("0.80"))
            ],
            "s_set_perfect": [
                ("s_attack_kill", Decimal("0.20")),    # Lower kill rate
                ("s_attack_in_play", Decimal("0.50")),
                ("s_attack_error", Decimal("0.15")),   # Higher error rate
                ("s_attack_blocked", Decimal("0.15"))
            ],
            "s_set_good": [
                ("s_attack_kill", Decimal("0.15")),
                ("s_attack_in_play", Decimal("0.50")),
                ("s_attack_error", Decimal("0.20")),
                ("s_attack_blocked", Decimal("0.15"))
            ]
        },
        
        # Novice receiving team - inconsistent reception and setting
        "novice_receiving": {
            "r_reception_perfect": [
                ("r_set_perfect", Decimal("0.50")),    # Lower perfect set rate
                ("r_set_good", Decimal("0.35")),
                ("r_set_error", Decimal("0.15"))       # Higher error rate
            ],
            "r_reception_good": [
                ("r_set_perfect", Decimal("0.25")),
                ("r_set_good", Decimal("0.40")),
                ("r_set_poor", Decimal("0.25")),
                ("r_set_error", Decimal("0.10"))
            ],
            "r_set_perfect": [
                ("r_attack_kill", Decimal("0.20")),    # Lower kill rate
                ("r_attack_in_play", Decimal("0.50")),
                ("r_attack_error", Decimal("0.15")),   # Higher error rate
                ("r_attack_blocked", Decimal("0.15"))
            ]
        },
        
        # Power serving team - aggressive serves
        "power_serving": {
            "s_serve_ready": [
                ("s_serve_ace", Decimal("0.15")),      # Very high ace rate
                ("s_serve_error", Decimal("0.15")),    # High error rate too
                ("s_serve_in_play", Decimal("0.70"))   # Lower in-play rate
            ]
        },
        
        # Consistent serving team - safe but effective
        "consistent_serving": {
            "s_serve_ready": [
                ("s_serve_ace", Decimal("0.03")),      # Low ace rate
                ("s_serve_error", Decimal("0.07")),    # Very low error rate
                ("s_serve_in_play", Decimal("0.90"))   # Very high in-play rate
            ]
        },
        
        # Defensive receiving team - good digs, consistent play
        "defensive_receiving": {
            "r_dig_perfect": [
                ("r_transition_set", Decimal("1.0"))   # Always transition to set
            ],
            "r_dig_good": [
                ("r_transition_set", Decimal("0.85")), # High transition rate
                ("r_transition_attack", Decimal("0.15"))
            ],
            "r_dig_poor": [
                ("r_transition_set", Decimal("0.50")), # Better recovery than default
                ("r_transition_attack", Decimal("0.35")),
                ("r_attack_error", Decimal("0.15"))
            ]
        }
    }
    
    return templates


def create_beach_volleyball_state_machine() -> RallyStateMachine:
    """Create the complete beach volleyball rally state machine.
    
    Returns:
        RallyStateMachine instance with all transitions defined
    """
    
    # Define all state transitions with realistic probabilities
    transitions: Dict[str, List[StateTransitionTuple]] = {
        # Serve states (serving team)
        "s_serve_ready": [
            ("s_serve_ace", Decimal("0.05"), ActionType.SERVE),
            ("s_serve_error", Decimal("0.10"), ActionType.SERVE),
            ("s_serve_in_play", Decimal("0.85"), ActionType.SERVE)
        ],
        
        # Serve in play transitions to reception
        "s_serve_in_play": [
            ("r_reception_perfect", Decimal("0.25"), ActionType.RECEPTION),
            ("r_reception_good", Decimal("0.45"), ActionType.RECEPTION),
            ("r_reception_poor", Decimal("0.25"), ActionType.RECEPTION),
            ("r_reception_error", Decimal("0.05"), ActionType.RECEPTION)
        ],
        
        # Reception to set transitions (receiving team)
        "r_reception_perfect": [
            ("r_set_perfect", Decimal("0.70"), ActionType.SET),
            ("r_set_good", Decimal("0.25"), ActionType.SET),
            ("r_set_error", Decimal("0.05"), ActionType.SET)
        ],
        
        "r_reception_good": [
            ("r_set_perfect", Decimal("0.40"), ActionType.SET),
            ("r_set_good", Decimal("0.45"), ActionType.SET),
            ("r_set_poor", Decimal("0.10"), ActionType.SET),
            ("r_set_error", Decimal("0.05"), ActionType.SET)
        ],
        
        "r_reception_poor": [
            ("r_set_poor", Decimal("0.60"), ActionType.SET),
            ("r_set_error", Decimal("0.25"), ActionType.SET),
            ("r_attack_error", Decimal("0.15"), ActionType.ATTACK)  # Emergency attack
        ],
        
        # Set to attack transitions (receiving team)
        "r_set_perfect": [
            ("r_attack_kill", Decimal("0.35"), ActionType.ATTACK),
            ("r_attack_in_play", Decimal("0.50"), ActionType.ATTACK),
            ("r_attack_error", Decimal("0.05"), ActionType.ATTACK),
            ("r_attack_blocked", Decimal("0.10"), ActionType.ATTACK)
        ],
        
        "r_set_good": [
            ("r_attack_kill", Decimal("0.25"), ActionType.ATTACK),
            ("r_attack_in_play", Decimal("0.55"), ActionType.ATTACK),
            ("r_attack_error", Decimal("0.10"), ActionType.ATTACK),
            ("r_attack_blocked", Decimal("0.10"), ActionType.ATTACK)
        ],
        
        "r_set_poor": [
            ("r_attack_in_play", Decimal("0.50"), ActionType.ATTACK),
            ("r_attack_error", Decimal("0.30"), ActionType.ATTACK),
            ("r_attack_blocked", Decimal("0.20"), ActionType.ATTACK)
        ],
        
        # Attack in play to defense (serving team response)
        "r_attack_in_play": [
            ("s_dig_perfect", Decimal("0.20"), ActionType.DIG),
            ("s_dig_good", Decimal("0.35"), ActionType.DIG),
            ("s_dig_poor", Decimal("0.30"), ActionType.DIG),
            ("s_dig_error", Decimal("0.15"), ActionType.DIG)
        ],
        
        # Attack blocked to block response (serving team)
        "r_attack_blocked": [
            ("s_block_kill", Decimal("0.30"), ActionType.BLOCK),
            ("s_block_controlled", Decimal("0.40"), ActionType.BLOCK),
            ("s_block_touch", Decimal("0.20"), ActionType.BLOCK),
            ("s_block_error", Decimal("0.10"), ActionType.BLOCK)
        ],
        
        # Dig to transition (serving team)
        "s_dig_perfect": [
            ("s_transition_set", Decimal("1.0"), ActionType.TRANSITION)
        ],
        
        "s_dig_good": [
            ("s_transition_set", Decimal("0.70"), ActionType.TRANSITION),
            ("s_transition_attack", Decimal("0.30"), ActionType.TRANSITION)
        ],
        
        "s_dig_poor": [
            ("s_transition_attack", Decimal("0.50"), ActionType.TRANSITION),
            ("s_transition_set", Decimal("0.30"), ActionType.TRANSITION),
            ("s_attack_error", Decimal("0.20"), ActionType.ATTACK)  # Direct error
        ],
        
        # Block controlled to transition (serving team)
        "s_block_controlled": [
            ("s_transition_set", Decimal("1.0"), ActionType.TRANSITION)
        ],
        
        # Block touch to dig (serving team)
        "s_block_touch": [
            ("s_dig_perfect", Decimal("0.25"), ActionType.DIG),
            ("s_dig_good", Decimal("0.40"), ActionType.DIG),
            ("s_dig_poor", Decimal("0.25"), ActionType.DIG),
            ("s_dig_error", Decimal("0.10"), ActionType.DIG)
        ],
        
        # Transition to set/attack (serving team)
        "s_transition_set": [
            ("s_set_perfect", Decimal("0.40"), ActionType.SET),
            ("s_set_good", Decimal("0.45"), ActionType.SET),
            ("s_set_poor", Decimal("0.10"), ActionType.SET),
            ("s_set_error", Decimal("0.05"), ActionType.SET)
        ],
        
        "s_transition_attack": [
            ("s_attack_kill", Decimal("0.20"), ActionType.ATTACK),
            ("s_attack_in_play", Decimal("0.60"), ActionType.ATTACK),
            ("s_attack_error", Decimal("0.15"), ActionType.ATTACK),
            ("s_attack_blocked", Decimal("0.05"), ActionType.ATTACK)
        ],
        
        # Set to attack (serving team)
        "s_set_perfect": [
            ("s_attack_kill", Decimal("0.35"), ActionType.ATTACK),
            ("s_attack_in_play", Decimal("0.50"), ActionType.ATTACK),
            ("s_attack_error", Decimal("0.05"), ActionType.ATTACK),
            ("s_attack_blocked", Decimal("0.10"), ActionType.ATTACK)
        ],
        
        "s_set_good": [
            ("s_attack_kill", Decimal("0.25"), ActionType.ATTACK),
            ("s_attack_in_play", Decimal("0.55"), ActionType.ATTACK),
            ("s_attack_error", Decimal("0.10"), ActionType.ATTACK),
            ("s_attack_blocked", Decimal("0.10"), ActionType.ATTACK)
        ],
        
        "s_set_poor": [
            ("s_attack_in_play", Decimal("0.50"), ActionType.ATTACK),
            ("s_attack_error", Decimal("0.30"), ActionType.ATTACK),
            ("s_attack_blocked", Decimal("0.20"), ActionType.ATTACK)
        ],
        
        # Attack in play to defense (receiving team response)
        "s_attack_in_play": [
            ("r_dig_perfect", Decimal("0.20"), ActionType.DIG),
            ("r_dig_good", Decimal("0.35"), ActionType.DIG),
            ("r_dig_poor", Decimal("0.30"), ActionType.DIG),
            ("r_dig_error", Decimal("0.15"), ActionType.DIG)
        ],
        
        # Attack blocked to block response (receiving team)
        "s_attack_blocked": [
            ("r_block_kill", Decimal("0.30"), ActionType.BLOCK),
            ("r_block_controlled", Decimal("0.40"), ActionType.BLOCK),
            ("r_block_touch", Decimal("0.20"), ActionType.BLOCK),
            ("r_block_error", Decimal("0.10"), ActionType.BLOCK)
        ],
        
        # Receiving team dig to transition
        "r_dig_perfect": [
            ("r_transition_set", Decimal("1.0"), ActionType.TRANSITION)
        ],
        
        "r_dig_good": [
            ("r_transition_set", Decimal("0.70"), ActionType.TRANSITION),
            ("r_transition_attack", Decimal("0.30"), ActionType.TRANSITION)
        ],
        
        "r_dig_poor": [
            ("r_transition_attack", Decimal("0.50"), ActionType.TRANSITION),
            ("r_transition_set", Decimal("0.30"), ActionType.TRANSITION),
            ("r_attack_error", Decimal("0.20"), ActionType.ATTACK)  # Direct error
        ],
        
        # Receiving team block controlled to transition
        "r_block_controlled": [
            ("r_transition_set", Decimal("1.0"), ActionType.TRANSITION)
        ],
        
        # Receiving team block touch to dig
        "r_block_touch": [
            ("r_dig_perfect", Decimal("0.25"), ActionType.DIG),
            ("r_dig_good", Decimal("0.40"), ActionType.DIG),
            ("r_dig_poor", Decimal("0.25"), ActionType.DIG),
            ("r_dig_error", Decimal("0.10"), ActionType.DIG)
        ],
        
        # Receiving team transition back to original flow
        "r_transition_set": [
            ("r_set_perfect", Decimal("0.40"), ActionType.SET),
            ("r_set_good", Decimal("0.45"), ActionType.SET),
            ("r_set_poor", Decimal("0.10"), ActionType.SET),
            ("r_set_error", Decimal("0.05"), ActionType.SET)
        ],
        
        "r_transition_attack": [
            ("r_attack_kill", Decimal("0.20"), ActionType.ATTACK),
            ("r_attack_in_play", Decimal("0.60"), ActionType.ATTACK),
            ("r_attack_error", Decimal("0.15"), ActionType.ATTACK),
            ("r_attack_blocked", Decimal("0.05"), ActionType.ATTACK)
        ]
    }
    
    # Define terminal states (rally-ending states)
    terminal_states = {
        "s_serve_ace",           # Serving team wins
        "s_serve_error",         # Receiving team wins
        "r_reception_error",     # Serving team wins
        "r_set_error",          # Serving team wins
        "r_attack_kill",        # Receiving team wins
        "r_attack_error",       # Serving team wins
        "s_dig_error",          # Receiving team wins
        "s_block_kill",         # Serving team wins
        "s_block_error",        # Receiving team wins
        "s_set_error",          # Receiving team wins
        "s_attack_kill",        # Serving team wins
        "s_attack_error",       # Receiving team wins
        "r_dig_error",          # Serving team wins
        "r_block_kill",         # Receiving team wins
        "r_block_error"         # Serving team wins
    }
    
    return RallyStateMachine(
        transitions=transitions,
        terminal_states=terminal_states,
        initial_state="s_serve_ready"
    )


def get_winning_team(terminal_state: str) -> str:
    """Determine which team wins based on terminal state.
    
    Args:
        terminal_state: The terminal state string
        
    Returns:
        'serving' if serving team wins, 'receiving' if receiving team wins
        
    Raises:
        ValueError: If state is not a terminal state
    """
    # States where serving team wins
    serving_team_wins = {
        "s_serve_ace", "r_reception_error", "r_set_error", "r_attack_error",
        "s_block_kill", "s_attack_kill", "r_dig_error", "r_block_error"
    }
    
    # States where receiving team wins  
    receiving_team_wins = {
        "s_serve_error", "r_attack_kill", "s_dig_error", "s_block_error",
        "s_set_error", "s_attack_error", "r_block_kill"
    }
    
    if terminal_state in serving_team_wins:
        return "serving"
    elif terminal_state in receiving_team_wins:
        return "receiving"
    else:
        raise ValueError(f"State {terminal_state} is not a recognized terminal state")


def simulate_rally_step(state_machine: RallyStateMachine, current_state: str) -> Optional[str]:
    """Simulate one step of the rally using weighted random selection based on probabilities.
    
    This function uses the transition probabilities to randomly select the next state,
    making the simulation more realistic and varied.
    
    Args:
        state_machine: The rally state machine
        current_state: Current state string
        
    Returns:
        Next state string, or None if current state is terminal
        
    Raises:
        ValueError: If current_state is invalid
    """
    import random
    
    if state_machine.is_terminal_state(current_state):
        return None
    
    transitions = state_machine.get_next_states(current_state)
    if not transitions:
        return None
    
    # Extract states and probabilities for weighted random selection
    states = [transition[0] for transition in transitions]
    probabilities = [float(transition[1]) for transition in transitions]
    
    # Use weighted random choice based on probabilities
    selected_state = random.choices(states, weights=probabilities, k=1)[0]
    return selected_state


def simulate_complete_rally(state_machine: RallyStateMachine, max_steps: int = 50) -> Tuple[List[str], str]:
    """Simulate a complete rally from start to finish.
    
    Args:
        state_machine: The rally state machine
        max_steps: Maximum number of steps to prevent infinite loops
        
    Returns:
        Tuple of (list of states in the rally, final outcome)
        
    Raises:
        RuntimeError: If rally doesn't terminate within max_steps
    """
    rally_sequence = []
    current_state = state_machine.initial_state
    step = 0
    
    while not state_machine.is_terminal_state(current_state) and step < max_steps:
        rally_sequence.append(current_state)
        next_state = simulate_rally_step(state_machine, current_state)
        
        if next_state is None:
            break
            
        current_state = next_state
        step += 1
    
    # Add the final terminal state
    if state_machine.is_terminal_state(current_state):
        rally_sequence.append(current_state)
        winner = get_winning_team(current_state)
        outcome = f"{winner} team wins"
    else:
        outcome = f"Rally exceeded {max_steps} steps"
    
    return rally_sequence, outcome


def print_state_machine_summary(state_machine: RallyStateMachine) -> None:
    """Print a summary of the state machine structure.
    
    Args:
        state_machine: The rally state machine to summarize
    """
    print("Beach Volleyball Rally State Machine Summary")
    print("=" * 50)
    print(f"Initial state: {state_machine.initial_state}")
    print(f"Total states: {len(state_machine.get_all_states())}")
    print(f"Terminal states: {len(state_machine.terminal_states)}")
    print(f"Continuation states: {len(state_machine.get_continuation_states())}")
    print(f"Probability validation: {state_machine.validate_probabilities()}")
    
    print(f"\nTerminal states:")
    for state in sorted(state_machine.terminal_states):
        winner = get_winning_team(state)
        print(f"  {state} -> {winner} team wins")
    
    print(f"\nSample transitions from initial state:")
    initial_transitions = state_machine.get_next_states(state_machine.initial_state)
    for next_state, probability, action_type in initial_transitions:
        print(f"  {state_machine.initial_state} -> {next_state} (p={probability}, {action_type})")


# Example usage and testing
if __name__ == "__main__":
    # Create the state machine
    rally_sm = create_beach_volleyball_state_machine()
    
    # Print summary
    print_state_machine_summary(rally_sm)
    
    # Test basic functionality
    print(f"\nFunctionality Tests:")
    print("=" * 30)
    
    current_state = rally_sm.initial_state
    print(f"Starting state: {current_state}")
    print(f"Acting team: {rally_sm.get_acting_team(current_state)}")
    print(f"Is terminal: {rally_sm.is_terminal_state(current_state)}")
    
    # Show transitions from current state
    transitions = rally_sm.get_next_states(current_state)
    print(f"\nPossible transitions from {current_state}:")
    for next_state, probability, action_type in transitions:
        print(f"  -> {next_state} (p={probability:.2f}, {action_type})")
    
    # Test transition validation
    print(f"\nTransition Validation Tests:")
    valid_next = transitions[0][0]  # First valid transition
    invalid_next = "invalid_state"
    
    print(f"Valid transition {current_state} -> {valid_next}: {rally_sm.is_valid_transition(current_state, valid_next)}")
    print(f"Invalid transition {current_state} -> {invalid_next}: {rally_sm.is_valid_transition(current_state, invalid_next)}")
    
    # Simulate a few rally steps with probability-based selection
    print(f"\nSimulated Rally Steps (Probability-Based):")
    print("=" * 45)
    
    rally_state = rally_sm.initial_state
    step = 0
    
    while rally_state and not rally_sm.is_terminal_state(rally_state) and step < 10:
        print(f"Step {step + 1}: {rally_state} (team: {rally_sm.get_acting_team(rally_state)})")
        next_state = simulate_rally_step(rally_sm, rally_state)
        if next_state:
            transitions = rally_sm.get_next_states(rally_state)
            chosen_transition = next(t for t in transitions if t[0] == next_state)
            print(f"  -> {next_state} (p={chosen_transition[1]:.2f}, {chosen_transition[2]})")
        rally_state = next_state
        step += 1
    
    # Final state
    if rally_state and rally_sm.is_terminal_state(rally_state):
        winner = get_winning_team(rally_state)
        print(f"\nRally ended: {rally_state}")
        print(f"Winner: {winner} team")
    elif step >= 10:
        print(f"\nRally simulation stopped after {step} steps (still in progress)")
    
    # Simulate multiple complete rallies
    print(f"\nComplete Rally Simulations:")
    print("=" * 30)
    
    serving_wins = 0
    receiving_wins = 0
    num_simulations = 5
    
    for i in range(num_simulations):
        rally_sequence, outcome = simulate_complete_rally(rally_sm)
        print(f"\nRally {i + 1}:")
        print(f"  Length: {len(rally_sequence)} steps")
        print(f"  Outcome: {outcome}")
        print(f"  Sequence: {' -> '.join(rally_sequence[:8])}{'...' if len(rally_sequence) > 8 else ''}")
        
        if "serving team wins" in outcome:
            serving_wins += 1
        elif "receiving team wins" in outcome:
            receiving_wins += 1
    
    print(f"\nSimulation Summary ({num_simulations} rallies):")
    print(f"  Serving team wins: {serving_wins}")
    print(f"  Receiving team wins: {receiving_wins}")
    print(f"  Win rate - Serving: {serving_wins/num_simulations:.1%}, Receiving: {receiving_wins/num_simulations:.1%}")
    
    # Test state machine validation
    print(f"\nValidation Results:")
    print("=" * 20)
    print(f"All probabilities valid: {rally_sm.validate_probabilities()}")
    
    # Show some statistics
    serving_states = [s for s in rally_sm.get_all_states() if s.startswith('s_')]
    receiving_states = [s for s in rally_sm.get_all_states() if s.startswith('r_')]
    
    print(f"Serving team states: {len(serving_states)}")
    print(f"Receiving team states: {len(receiving_states)}")
    
    print("\nDictionary-based state machine loaded successfully!")
    
    # Example usage of create_state_machine_from_teams function
    print("\n" + "="*60)
    print("TESTING CUSTOM TEAM PROBABILITIES FUNCTION")
    print("="*60)
    
    # Example: Create custom team probabilities
    example_serving_probs = {
        "s_serve_ready": [
            ("s_serve_ace", Decimal("0.08")),
            ("s_serve_error", Decimal("0.12")),
            ("s_serve_in_play", Decimal("0.80"))
        ],
        "s_set_perfect": [
            ("s_attack_kill", Decimal("0.40")),  # Higher kill rate than default
            ("s_attack_in_play", Decimal("0.45")),
            ("s_attack_error", Decimal("0.05")),
            ("s_attack_blocked", Decimal("0.10"))
        ]
    }
    
    example_receiving_probs = {
        "r_reception_perfect": [
            ("r_set_perfect", Decimal("0.80")),  # Higher perfect set rate
            ("r_set_good", Decimal("0.15")),
            ("r_set_error", Decimal("0.05"))
        ],
        "r_set_good": [
            ("r_attack_kill", Decimal("0.30")),  # Higher kill rate from good sets
            ("r_attack_in_play", Decimal("0.50")),
            ("r_attack_error", Decimal("0.10")),
            ("r_attack_blocked", Decimal("0.10"))
        ]
    }
    
    try:
        # Create custom state machine
        custom_sm = create_state_machine_from_teams(
            example_serving_probs, 
            example_receiving_probs
        )
        
        print("✓ Custom state machine created successfully!")
        print(f"  Total states: {len(custom_sm.get_all_states())}")
        print(f"  Validation passed: {custom_sm.validate_probabilities()}")
        
        # Compare custom vs default probabilities for specific states
        print("\nComparison of Custom vs Default Probabilities:")
        print("-" * 50)
        
        default_sm = create_beach_volleyball_state_machine()
        
        test_states = ["s_serve_ready", "r_reception_perfect"]
        for state in test_states:
            if state in custom_sm.transitions and state in default_sm.transitions:
                print(f"\nState: {state}")
                print("  Custom transitions:")
                for next_state, prob, action in custom_sm.get_next_states(state):
                    print(f"    -> {next_state}: {prob}")
                print("  Default transitions:")
                for next_state, prob, action in default_sm.get_next_states(state):
                    print(f"    -> {next_state}: {prob}")
        
        # Run a quick simulation with custom probabilities
        print(f"\nSimulating rally with custom probabilities:")
        custom_rally, custom_outcome = simulate_complete_rally(custom_sm)
        print(f"  Rally length: {len(custom_rally)} steps")
        print(f"  Outcome: {custom_outcome}")
        print(f"  First 5 states: {' -> '.join(custom_rally[:5])}")
        
    except ValueError as e:
        print(f"✗ Error creating custom state machine: {e}")
    
    # Test error handling with invalid probabilities
    print(f"\nTesting error handling:")
    print("-" * 30)
    
    # Test case 1: Probabilities don't sum to 1.0
    invalid_serving_probs = {
        "s_serve_ready": [
            ("s_serve_ace", Decimal("0.05")),
            ("s_serve_error", Decimal("0.10")),
            ("s_serve_in_play", Decimal("0.80"))  # Sum = 0.95, not 1.0
        ]
    }
    
    try:
        create_state_machine_from_teams(invalid_serving_probs, {})
        print("✗ Should have caught invalid probabilities")
    except ValueError as e:
        print(f"✓ Correctly caught invalid probabilities: {str(e)[:80]}...")
    
    # Test case 2: Invalid state name (doesn't start with s_ or r_)
    invalid_state_name = {
        "invalid_state": [
            ("s_serve_ace", Decimal("1.0"))
        ]
    }
    
    try:
        create_state_machine_from_teams(invalid_state_name, {})
        print("✗ Should have caught invalid state name")
    except ValueError as e:
        print(f"✓ Correctly caught invalid state name: {str(e)[:80]}...")
    
    # Test the template system
    print(f"\nTesting Common State Templates:")
    print("-" * 40)
    
    templates = get_common_state_templates()
    print(f"Available templates: {list(templates.keys())}")
    
    # Create a state machine using templates
    try:
        elite_vs_novice_sm = create_state_machine_from_teams(
            templates["elite_serving"],
            templates["novice_receiving"]
        )
        print(f"✓ Elite vs Novice state machine created successfully!")
        
        # Run a quick comparison simulation
        elite_rally, elite_outcome = simulate_complete_rally(elite_vs_novice_sm)
        print(f"  Elite vs Novice rally: {len(elite_rally)} steps, {elite_outcome}")
        
        # Compare with power serving vs defensive receiving
        power_vs_defense_sm = create_state_machine_from_teams(
            templates["power_serving"],
            templates["defensive_receiving"]
        )
        power_rally, power_outcome = simulate_complete_rally(power_vs_defense_sm)
        print(f"  Power vs Defense rally: {len(power_rally)} steps, {power_outcome}")
        
    except Exception as e:
        print(f"✗ Template test failed: {e}")
    
    print(f"\nCustom team probabilities function testing complete!")
