# /// script
# requires-python = ">=3.9"
# dependencies = []
# ///
"""Beach Volleyball Rally State Machine - Dictionary Representation

A functional approach to modeling beach volleyball rally states using a dictionary-based
representation. This module provides a simplified state machine structure where states
are represented as strings and transitions as tuples.

Key Features:
- Dictionary-based state representation for easy lookup
- Functional programming style with immutable data structures
- Comprehensive error handling and validation
- Type hints throughout for better code clarity
- Self-contained with no external dependencies
- Detailed documentation with examples

Dictionary Structure:
- Key: String representing the rally state
- Value: Tuple of (to_rally_state_string, probability, action_type)

Team Convention:
- s_ prefix states: Team A (serving team) actions
- r_ prefix states: Team B (receiving team) actions

Author: Generated by AI Assistant
Date: July 11, 2025
Python Version: 3.9+
"""

from typing import Dict, List, Tuple, Optional, Set
from decimal import Decimal
from dataclasses import dataclass
from enum import Enum


class ActionType(str, Enum):
    """Types of actions that can occur in a rally."""
    
    SERVE = "serve"
    RECEPTION = "reception"
    SET = "set"
    ATTACK = "attack"
    DIG = "dig"
    BLOCK = "block"
    TRANSITION = "transition"


# Type alias for state transition tuple
StateTransitionTuple = Tuple[str, Decimal, ActionType]


@dataclass
class RallyStateMachine:
    """Dictionary-based rally state machine for beach volleyball.
    
    This class encapsulates the state machine logic using a dictionary representation
    where each state maps to possible transitions with their probabilities and action types.
    
    Attributes:
        transitions: Dictionary mapping state strings to lists of transition tuples
        terminal_states: Set of state strings that end the rally
        initial_state: The starting state for a new rally
    """
    
    transitions: Dict[str, List[StateTransitionTuple]]
    terminal_states: Set[str]
    initial_state: str = "s_serve_ready"
    
    def get_next_states(self, current_state: str) -> List[StateTransitionTuple]:
        """Get possible next states from current state.
        
        Args:
            current_state: Current rally state as string
            
        Returns:
            List of transition tuples (next_state, probability, action_type)
            
        Raises:
            ValueError: If current_state is not in the state machine
        """
        if current_state not in self.transitions:
            raise ValueError(f"Invalid state: {current_state}")
        
        return self.transitions[current_state]
    
    def is_terminal_state(self, state: str) -> bool:
        """Check if a state is terminal (ends the rally).
        
        Args:
            state: State string to check
            
        Returns:
            True if state is terminal, False otherwise
        """
        return state in self.terminal_states
    
    def is_valid_transition(self, from_state: str, to_state: str) -> bool:
        """Check if a transition between states is valid.
        
        Args:
            from_state: Starting state
            to_state: Destination state
            
        Returns:
            True if transition is valid, False otherwise
        """
        if from_state not in self.transitions:
            return False
        
        valid_next_states = [transition[0] for transition in self.transitions[from_state]]
        return to_state in valid_next_states
    
    def get_acting_team(self, state: str) -> str:
        """Get which team is acting in the given state.
        
        Args:
            state: Rally state string
            
        Returns:
            'serving' if serving team acts, 'receiving' if receiving team acts,
            'terminal' if rally is over
        """
        if state.startswith('s_'):
            return 'serving'
        elif state.startswith('r_'):
            return 'receiving'
        else:
            return 'terminal'
    
    def get_all_states(self) -> Set[str]:
        """Get all states in the state machine.
        
        Returns:
            Set of all state strings
        """
        all_states = set(self.transitions.keys())
        all_states.update(self.terminal_states)
        return all_states
    
    def get_continuation_states(self) -> Set[str]:
        """Get all non-terminal states.
        
        Returns:
            Set of continuation state strings
        """
        return self.get_all_states() - self.terminal_states
    
    def validate_probabilities(self) -> bool:
        """Validate that all transition probabilities sum to 1.0 for each state.
        
        Returns:
            True if all probabilities are valid, False otherwise
        """
        for state, transitions in self.transitions.items():
            if not transitions:  # Skip states with no transitions
                continue
                
            total_probability = sum(transition[1] for transition in transitions)
            if abs(total_probability - Decimal("1.0")) > Decimal("0.001"):
                print(f"Warning: State {state} probabilities sum to {total_probability}, not 1.0")
                return False
        
        return True


def create_beach_volleyball_state_machine() -> RallyStateMachine:
    """Create the complete beach volleyball rally state machine.
    
    Returns:
        RallyStateMachine instance with all transitions defined
    """
    
    # Define all state transitions with realistic probabilities
    transitions: Dict[str, List[StateTransitionTuple]] = {
        # Serve states (serving team)
        "s_serve_ready": [
            ("s_serve_ace", Decimal("0.05"), ActionType.SERVE),
            ("s_serve_error", Decimal("0.10"), ActionType.SERVE),
            ("s_serve_in_play", Decimal("0.85"), ActionType.SERVE)
        ],
        
        # Serve in play transitions to reception
        "s_serve_in_play": [
            ("r_reception_perfect", Decimal("0.25"), ActionType.RECEPTION),
            ("r_reception_good", Decimal("0.45"), ActionType.RECEPTION),
            ("r_reception_poor", Decimal("0.25"), ActionType.RECEPTION),
            ("r_reception_error", Decimal("0.05"), ActionType.RECEPTION)
        ],
        
        # Reception to set transitions (receiving team)
        "r_reception_perfect": [
            ("r_set_perfect", Decimal("0.70"), ActionType.SET),
            ("r_set_good", Decimal("0.25"), ActionType.SET),
            ("r_set_error", Decimal("0.05"), ActionType.SET)
        ],
        
        "r_reception_good": [
            ("r_set_perfect", Decimal("0.40"), ActionType.SET),
            ("r_set_good", Decimal("0.45"), ActionType.SET),
            ("r_set_poor", Decimal("0.10"), ActionType.SET),
            ("r_set_error", Decimal("0.05"), ActionType.SET)
        ],
        
        "r_reception_poor": [
            ("r_set_poor", Decimal("0.60"), ActionType.SET),
            ("r_set_error", Decimal("0.25"), ActionType.SET),
            ("r_attack_error", Decimal("0.15"), ActionType.ATTACK)  # Emergency attack
        ],
        
        # Set to attack transitions (receiving team)
        "r_set_perfect": [
            ("r_attack_kill", Decimal("0.35"), ActionType.ATTACK),
            ("r_attack_in_play", Decimal("0.50"), ActionType.ATTACK),
            ("r_attack_error", Decimal("0.05"), ActionType.ATTACK),
            ("r_attack_blocked", Decimal("0.10"), ActionType.ATTACK)
        ],
        
        "r_set_good": [
            ("r_attack_kill", Decimal("0.25"), ActionType.ATTACK),
            ("r_attack_in_play", Decimal("0.55"), ActionType.ATTACK),
            ("r_attack_error", Decimal("0.10"), ActionType.ATTACK),
            ("r_attack_blocked", Decimal("0.10"), ActionType.ATTACK)
        ],
        
        "r_set_poor": [
            ("r_attack_in_play", Decimal("0.50"), ActionType.ATTACK),
            ("r_attack_error", Decimal("0.30"), ActionType.ATTACK),
            ("r_attack_blocked", Decimal("0.20"), ActionType.ATTACK)
        ],
        
        # Attack in play to defense (serving team response)
        "r_attack_in_play": [
            ("s_dig_perfect", Decimal("0.20"), ActionType.DIG),
            ("s_dig_good", Decimal("0.35"), ActionType.DIG),
            ("s_dig_poor", Decimal("0.30"), ActionType.DIG),
            ("s_dig_error", Decimal("0.15"), ActionType.DIG)
        ],
        
        # Attack blocked to block response (serving team)
        "r_attack_blocked": [
            ("s_block_kill", Decimal("0.30"), ActionType.BLOCK),
            ("s_block_controlled", Decimal("0.40"), ActionType.BLOCK),
            ("s_block_touch", Decimal("0.20"), ActionType.BLOCK),
            ("s_block_error", Decimal("0.10"), ActionType.BLOCK)
        ],
        
        # Dig to transition (serving team)
        "s_dig_perfect": [
            ("s_transition_set", Decimal("1.0"), ActionType.TRANSITION)
        ],
        
        "s_dig_good": [
            ("s_transition_set", Decimal("0.70"), ActionType.TRANSITION),
            ("s_transition_attack", Decimal("0.30"), ActionType.TRANSITION)
        ],
        
        "s_dig_poor": [
            ("s_transition_attack", Decimal("0.50"), ActionType.TRANSITION),
            ("s_transition_set", Decimal("0.30"), ActionType.TRANSITION),
            ("s_attack_error", Decimal("0.20"), ActionType.ATTACK)  # Direct error
        ],
        
        # Block controlled to transition (serving team)
        "s_block_controlled": [
            ("s_transition_set", Decimal("1.0"), ActionType.TRANSITION)
        ],
        
        # Block touch to dig (serving team)
        "s_block_touch": [
            ("s_dig_perfect", Decimal("0.25"), ActionType.DIG),
            ("s_dig_good", Decimal("0.40"), ActionType.DIG),
            ("s_dig_poor", Decimal("0.25"), ActionType.DIG),
            ("s_dig_error", Decimal("0.10"), ActionType.DIG)
        ],
        
        # Transition to set/attack (serving team)
        "s_transition_set": [
            ("s_set_perfect", Decimal("0.40"), ActionType.SET),
            ("s_set_good", Decimal("0.45"), ActionType.SET),
            ("s_set_poor", Decimal("0.10"), ActionType.SET),
            ("s_set_error", Decimal("0.05"), ActionType.SET)
        ],
        
        "s_transition_attack": [
            ("s_attack_kill", Decimal("0.20"), ActionType.ATTACK),
            ("s_attack_in_play", Decimal("0.60"), ActionType.ATTACK),
            ("s_attack_error", Decimal("0.15"), ActionType.ATTACK),
            ("s_attack_blocked", Decimal("0.05"), ActionType.ATTACK)
        ],
        
        # Set to attack (serving team)
        "s_set_perfect": [
            ("s_attack_kill", Decimal("0.35"), ActionType.ATTACK),
            ("s_attack_in_play", Decimal("0.50"), ActionType.ATTACK),
            ("s_attack_error", Decimal("0.05"), ActionType.ATTACK),
            ("s_attack_blocked", Decimal("0.10"), ActionType.ATTACK)
        ],
        
        "s_set_good": [
            ("s_attack_kill", Decimal("0.25"), ActionType.ATTACK),
            ("s_attack_in_play", Decimal("0.55"), ActionType.ATTACK),
            ("s_attack_error", Decimal("0.10"), ActionType.ATTACK),
            ("s_attack_blocked", Decimal("0.10"), ActionType.ATTACK)
        ],
        
        "s_set_poor": [
            ("s_attack_in_play", Decimal("0.50"), ActionType.ATTACK),
            ("s_attack_error", Decimal("0.30"), ActionType.ATTACK),
            ("s_attack_blocked", Decimal("0.20"), ActionType.ATTACK)
        ],
        
        # Attack in play to defense (receiving team response)
        "s_attack_in_play": [
            ("r_dig_perfect", Decimal("0.20"), ActionType.DIG),
            ("r_dig_good", Decimal("0.35"), ActionType.DIG),
            ("r_dig_poor", Decimal("0.30"), ActionType.DIG),
            ("r_dig_error", Decimal("0.15"), ActionType.DIG)
        ],
        
        # Attack blocked to block response (receiving team)
        "s_attack_blocked": [
            ("r_block_kill", Decimal("0.30"), ActionType.BLOCK),
            ("r_block_controlled", Decimal("0.40"), ActionType.BLOCK),
            ("r_block_touch", Decimal("0.20"), ActionType.BLOCK),
            ("r_block_error", Decimal("0.10"), ActionType.BLOCK)
        ],
        
        # Receiving team dig to transition
        "r_dig_perfect": [
            ("r_transition_set", Decimal("1.0"), ActionType.TRANSITION)
        ],
        
        "r_dig_good": [
            ("r_transition_set", Decimal("0.70"), ActionType.TRANSITION),
            ("r_transition_attack", Decimal("0.30"), ActionType.TRANSITION)
        ],
        
        "r_dig_poor": [
            ("r_transition_attack", Decimal("0.50"), ActionType.TRANSITION),
            ("r_transition_set", Decimal("0.30"), ActionType.TRANSITION),
            ("r_attack_error", Decimal("0.20"), ActionType.ATTACK)  # Direct error
        ],
        
        # Receiving team block controlled to transition
        "r_block_controlled": [
            ("r_transition_set", Decimal("1.0"), ActionType.TRANSITION)
        ],
        
        # Receiving team block touch to dig
        "r_block_touch": [
            ("r_dig_perfect", Decimal("0.25"), ActionType.DIG),
            ("r_dig_good", Decimal("0.40"), ActionType.DIG),
            ("r_dig_poor", Decimal("0.25"), ActionType.DIG),
            ("r_dig_error", Decimal("0.10"), ActionType.DIG)
        ],
        
        # Receiving team transition back to original flow
        "r_transition_set": [
            ("r_set_perfect", Decimal("0.40"), ActionType.SET),
            ("r_set_good", Decimal("0.45"), ActionType.SET),
            ("r_set_poor", Decimal("0.10"), ActionType.SET),
            ("r_set_error", Decimal("0.05"), ActionType.SET)
        ],
        
        "r_transition_attack": [
            ("r_attack_kill", Decimal("0.20"), ActionType.ATTACK),
            ("r_attack_in_play", Decimal("0.60"), ActionType.ATTACK),
            ("r_attack_error", Decimal("0.15"), ActionType.ATTACK),
            ("r_attack_blocked", Decimal("0.05"), ActionType.ATTACK)
        ]
    }
    
    # Define terminal states (rally-ending states)
    terminal_states = {
        "s_serve_ace",           # Serving team wins
        "s_serve_error",         # Receiving team wins
        "r_reception_error",     # Serving team wins
        "r_set_error",          # Serving team wins
        "r_attack_kill",        # Receiving team wins
        "r_attack_error",       # Serving team wins
        "s_dig_error",          # Receiving team wins
        "s_block_kill",         # Serving team wins
        "s_block_error",        # Receiving team wins
        "s_set_error",          # Receiving team wins
        "s_attack_kill",        # Serving team wins
        "s_attack_error",       # Receiving team wins
        "r_dig_error",          # Serving team wins
        "r_block_kill",         # Receiving team wins
        "r_block_error"         # Serving team wins
    }
    
    return RallyStateMachine(
        transitions=transitions,
        terminal_states=terminal_states,
        initial_state="s_serve_ready"
    )


def get_winning_team(terminal_state: str) -> str:
    """Determine which team wins based on terminal state.
    
    Args:
        terminal_state: The terminal state string
        
    Returns:
        'serving' if serving team wins, 'receiving' if receiving team wins
        
    Raises:
        ValueError: If state is not a terminal state
    """
    # States where serving team wins
    serving_team_wins = {
        "s_serve_ace", "r_reception_error", "r_set_error", "r_attack_error",
        "s_block_kill", "s_attack_kill", "r_dig_error", "r_block_error"
    }
    
    # States where receiving team wins  
    receiving_team_wins = {
        "s_serve_error", "r_attack_kill", "s_dig_error", "s_block_error",
        "s_set_error", "s_attack_error", "r_block_kill"
    }
    
    if terminal_state in serving_team_wins:
        return "serving"
    elif terminal_state in receiving_team_wins:
        return "receiving"
    else:
        raise ValueError(f"State {terminal_state} is not a recognized terminal state")


def simulate_rally_step(state_machine: RallyStateMachine, current_state: str) -> Optional[str]:
    """Simulate one step of the rally using weighted random selection based on probabilities.
    
    This function uses the transition probabilities to randomly select the next state,
    making the simulation more realistic and varied.
    
    Args:
        state_machine: The rally state machine
        current_state: Current state string
        
    Returns:
        Next state string, or None if current state is terminal
        
    Raises:
        ValueError: If current_state is invalid
    """
    import random
    
    if state_machine.is_terminal_state(current_state):
        return None
    
    transitions = state_machine.get_next_states(current_state)
    if not transitions:
        return None
    
    # Extract states and probabilities for weighted random selection
    states = [transition[0] for transition in transitions]
    probabilities = [float(transition[1]) for transition in transitions]
    
    # Use weighted random choice based on probabilities
    selected_state = random.choices(states, weights=probabilities, k=1)[0]
    return selected_state


def simulate_complete_rally(state_machine: RallyStateMachine, max_steps: int = 50) -> Tuple[List[str], str]:
    """Simulate a complete rally from start to finish.
    
    Args:
        state_machine: The rally state machine
        max_steps: Maximum number of steps to prevent infinite loops
        
    Returns:
        Tuple of (list of states in the rally, final outcome)
        
    Raises:
        RuntimeError: If rally doesn't terminate within max_steps
    """
    rally_sequence = []
    current_state = state_machine.initial_state
    step = 0
    
    while not state_machine.is_terminal_state(current_state) and step < max_steps:
        rally_sequence.append(current_state)
        next_state = simulate_rally_step(state_machine, current_state)
        
        if next_state is None:
            break
            
        current_state = next_state
        step += 1
    
    # Add the final terminal state
    if state_machine.is_terminal_state(current_state):
        rally_sequence.append(current_state)
        winner = get_winning_team(current_state)
        outcome = f"{winner} team wins"
    else:
        outcome = f"Rally exceeded {max_steps} steps"
    
    return rally_sequence, outcome


def print_state_machine_summary(state_machine: RallyStateMachine) -> None:
    """Print a summary of the state machine structure.
    
    Args:
        state_machine: The rally state machine to summarize
    """
    print("Beach Volleyball Rally State Machine Summary")
    print("=" * 50)
    print(f"Initial state: {state_machine.initial_state}")
    print(f"Total states: {len(state_machine.get_all_states())}")
    print(f"Terminal states: {len(state_machine.terminal_states)}")
    print(f"Continuation states: {len(state_machine.get_continuation_states())}")
    print(f"Probability validation: {state_machine.validate_probabilities()}")
    
    print(f"\nTerminal states:")
    for state in sorted(state_machine.terminal_states):
        winner = get_winning_team(state)
        print(f"  {state} -> {winner} team wins")
    
    print(f"\nSample transitions from initial state:")
    initial_transitions = state_machine.get_next_states(state_machine.initial_state)
    for next_state, probability, action_type in initial_transitions:
        print(f"  {state_machine.initial_state} -> {next_state} (p={probability}, {action_type})")


# Example usage and testing
if __name__ == "__main__":
    # Create the state machine
    rally_sm = create_beach_volleyball_state_machine()
    
    # Print summary
    print_state_machine_summary(rally_sm)
    
    # Test basic functionality
    print(f"\nFunctionality Tests:")
    print("=" * 30)
    
    current_state = rally_sm.initial_state
    print(f"Starting state: {current_state}")
    print(f"Acting team: {rally_sm.get_acting_team(current_state)}")
    print(f"Is terminal: {rally_sm.is_terminal_state(current_state)}")
    
    # Show transitions from current state
    transitions = rally_sm.get_next_states(current_state)
    print(f"\nPossible transitions from {current_state}:")
    for next_state, probability, action_type in transitions:
        print(f"  -> {next_state} (p={probability:.2f}, {action_type})")
    
    # Test transition validation
    print(f"\nTransition Validation Tests:")
    valid_next = transitions[0][0]  # First valid transition
    invalid_next = "invalid_state"
    
    print(f"Valid transition {current_state} -> {valid_next}: {rally_sm.is_valid_transition(current_state, valid_next)}")
    print(f"Invalid transition {current_state} -> {invalid_next}: {rally_sm.is_valid_transition(current_state, invalid_next)}")
    
    # Simulate a few rally steps with probability-based selection
    print(f"\nSimulated Rally Steps (Probability-Based):")
    print("=" * 45)
    
    rally_state = rally_sm.initial_state
    step = 0
    
    while rally_state and not rally_sm.is_terminal_state(rally_state) and step < 10:
        print(f"Step {step + 1}: {rally_state} (team: {rally_sm.get_acting_team(rally_state)})")
        next_state = simulate_rally_step(rally_sm, rally_state)
        if next_state:
            transitions = rally_sm.get_next_states(rally_state)
            chosen_transition = next(t for t in transitions if t[0] == next_state)
            print(f"  -> {next_state} (p={chosen_transition[1]:.2f}, {chosen_transition[2]})")
        rally_state = next_state
        step += 1
    
    # Final state
    if rally_state and rally_sm.is_terminal_state(rally_state):
        winner = get_winning_team(rally_state)
        print(f"\nRally ended: {rally_state}")
        print(f"Winner: {winner} team")
    elif step >= 10:
        print(f"\nRally simulation stopped after {step} steps (still in progress)")
    
    # Simulate multiple complete rallies
    print(f"\nComplete Rally Simulations:")
    print("=" * 30)
    
    serving_wins = 0
    receiving_wins = 0
    num_simulations = 5
    
    for i in range(num_simulations):
        rally_sequence, outcome = simulate_complete_rally(rally_sm)
        print(f"\nRally {i + 1}:")
        print(f"  Length: {len(rally_sequence)} steps")
        print(f"  Outcome: {outcome}")
        print(f"  Sequence: {' -> '.join(rally_sequence[:8])}{'...' if len(rally_sequence) > 8 else ''}")
        
        if "serving team wins" in outcome:
            serving_wins += 1
        elif "receiving team wins" in outcome:
            receiving_wins += 1
    
    print(f"\nSimulation Summary ({num_simulations} rallies):")
    print(f"  Serving team wins: {serving_wins}")
    print(f"  Receiving team wins: {receiving_wins}")
    print(f"  Win rate - Serving: {serving_wins/num_simulations:.1%}, Receiving: {receiving_wins/num_simulations:.1%}")
    
    # Test state machine validation
    print(f"\nValidation Results:")
    print("=" * 20)
    print(f"All probabilities valid: {rally_sm.validate_probabilities()}")
    
    # Show some statistics
    serving_states = [s for s in rally_sm.get_all_states() if s.startswith('s_')]
    receiving_states = [s for s in rally_sm.get_all_states() if s.startswith('r_')]
    
    print(f"Serving team states: {len(serving_states)}")
    print(f"Receiving team states: {len(receiving_states)}")
    
    print("\nDictionary-based state machine loaded successfully!")
