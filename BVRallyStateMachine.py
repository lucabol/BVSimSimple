# /// script
# requires-python = ">=3.9"
# dependencies = []
# ///
"""Beach Volleyball Rally State Machine

A functional approach to modeling beach volleyball rally states with separate
serving and receiving team actions. This module provides a comprehensive
state machine for realistic rally simulation.

Key Features:
- Functional programming style with immutable data structures
- Comprehensive error handling and validation
- Type hints throughout for better code clarity
- Self-contained with no external dependencies
- Detailed documentation with examples

Team Convention:
- Team A is always the serving team
- Team B is always the receiving team
- S_ prefix states: Team A (serving team) actions
- R_ prefix states: Team B (receiving team) actions

The state machine handles:
- Serve actions (serving team)
- Reception actions (receiving team) 
- Setting and attacking phases (alternating teams)
- Defense and blocking (opponent team)
- Transition states between rally phases
- Terminal states (point won/lost)

Author: Generated by AI Assistant
Date: July 11, 2025
Python Version: 3.9+
"""

from enum import Enum
from typing import Dict, List, Optional, Any, Tuple, NamedTuple
from dataclasses import dataclass
from decimal import Decimal


class RallyState(str, Enum):
    """Enumeration of all possible rally states in beach volleyball.
    
    States are prefixed with:
    - S_ for serving team actions
    - R_ for receiving team actions
    - TERMINAL_ for rally-ending states
    """
    
    # Serve states (serving team)
    S_SERVE_READY = "s_serve_ready"
    S_SERVE_ACE = "s_serve_ace"
    S_SERVE_ERROR = "s_serve_error"
    S_SERVE_IN_PLAY = "s_serve_in_play"
    
    # Reception states (receiving team)
    R_RECEPTION_PERFECT = "r_reception_perfect"
    R_RECEPTION_GOOD = "r_reception_good"
    R_RECEPTION_POOR = "r_reception_poor"
    R_RECEPTION_ERROR = "r_reception_error"
    
    # Setting states (receiving team after reception)
    R_SET_PERFECT = "r_set_perfect"
    R_SET_GOOD = "r_set_good"
    R_SET_POOR = "r_set_poor"
    R_SET_ERROR = "r_set_error"
    
    # Attack states (receiving team)
    R_ATTACK_KILL = "r_attack_kill"
    R_ATTACK_ERROR = "r_attack_error"
    R_ATTACK_IN_PLAY = "r_attack_in_play"
    R_ATTACK_BLOCKED = "r_attack_blocked"
    
    # Defense states (serving team defending)
    S_DIG_PERFECT = "s_dig_perfect"
    S_DIG_GOOD = "s_dig_good"
    S_DIG_POOR = "s_dig_poor"
    S_DIG_ERROR = "s_dig_error"
    
    # Block states (serving team blocking)
    S_BLOCK_KILL = "s_block_kill"
    S_BLOCK_CONTROLLED = "s_block_controlled"
    S_BLOCK_ERROR = "s_block_error"
    S_BLOCK_TOUCH = "s_block_touch"
    
    # Transition states (serving team after dig)
    S_TRANSITION_SET = "s_transition_set"
    S_TRANSITION_ATTACK = "s_transition_attack"
    
    # Setting states (serving team in transition)
    S_SET_PERFECT = "s_set_perfect"
    S_SET_GOOD = "s_set_good"
    S_SET_POOR = "s_set_poor"
    S_SET_ERROR = "s_set_error"
    
    # Attack states (serving team in transition)
    S_ATTACK_KILL = "s_attack_kill"
    S_ATTACK_ERROR = "s_attack_error"
    S_ATTACK_IN_PLAY = "s_attack_in_play"
    S_ATTACK_BLOCKED = "s_attack_blocked"
    
    # Defense states (receiving team defending counter-attack)
    R_DIG_PERFECT = "r_dig_perfect"
    R_DIG_GOOD = "r_dig_good"
    R_DIG_POOR = "r_dig_poor"
    R_DIG_ERROR = "r_dig_error"
    
    # Block states (receiving team blocking counter-attack)
    R_BLOCK_KILL = "r_block_kill"
    R_BLOCK_CONTROLLED = "r_block_controlled"
    R_BLOCK_ERROR = "r_block_error"
    R_BLOCK_TOUCH = "r_block_touch"
    
    # Transition states (receiving team after counter-dig)
    R_TRANSITION_SET = "r_transition_set"
    R_TRANSITION_ATTACK = "r_transition_attack"
    
    # Terminal states
    TERMINAL_SERVING_TEAM_WINS = "terminal_serving_team_wins"
    TERMINAL_RECEIVING_TEAM_WINS = "terminal_receiving_team_wins"
    TERMINAL_RALLY_CONTINUATION = "terminal_rally_continuation"


class ActionType(str, Enum):
    """Types of actions that can occur in a rally."""
    
    SERVE = "serve"
    RECEPTION = "reception"
    SET = "set"
    ATTACK = "attack"
    DIG = "dig"
    BLOCK = "block"
    TRANSITION = "transition"


class TeamSide(str, Enum):
    """Which team is performing the action."""
    
    TEAM_A = "team_a"
    TEAM_B = "team_b"


class StateTransition(NamedTuple):
    """Represents a state transition with probability and metadata.
    
    This is a lightweight, immutable data structure for representing
    state transitions in the rally state machine.
    
    Example:
        transition = StateTransition(
            from_state=RallyState.S_SERVE_READY,
            to_state=RallyState.S_SERVE_IN_PLAY,
            probability=Decimal("0.75"),
            action_type=ActionType.SERVE,
            performing_team=TeamSide.TEAM_A
        )
    """
    
    from_state: RallyState
    to_state: RallyState
    probability: Decimal
    action_type: ActionType
    performing_team: TeamSide
    conditions: Optional[Dict[str, Any]] = None
    description: Optional[str] = None


def create_state_transition(
    from_state: RallyState,
    to_state: RallyState,
    probability: Decimal,
    action_type: ActionType,
    performing_team: TeamSide,
    conditions: Optional[Dict[str, Any]] = None,
    description: Optional[str] = None
) -> StateTransition:
    """Factory function to create a validated StateTransition.
    
    Args:
        from_state: The source state
        to_state: The destination state
        probability: Transition probability (0.0 to 1.0)
        action_type: Type of action causing the transition
        performing_team: Team performing the action
        conditions: Optional conditions for the transition
        description: Optional description of the transition
        
    Returns:
        A validated StateTransition instance
        
    Raises:
        ValueError: If probability is not between 0 and 1
    """
    if not (0 <= probability <= 1):
        raise ValueError(f"Probability must be between 0 and 1, got {probability}")
    
    return StateTransition(
        from_state=from_state,
        to_state=to_state,
        probability=probability,
        action_type=action_type,
        performing_team=performing_team,
        conditions=conditions,
        description=description
    )


@dataclass
class RallyContext:
    """Context information for the current rally state.
    
    Simplified version for single point simulation - contains only
    essential information needed to track rally state transitions.
    Assumes team_a is always the serving team.
    """
    
    # Essential state tracking
    current_state: RallyState
    rally_length: int = 0
    
    # Optional factors that can influence probabilities
    momentum: Decimal = Decimal("0.0")        # -1 to 1, team momentum
    pressure_level: Decimal = Decimal("0.0")  # 0 to 1, pressure intensity
    fatigue_team_a: Decimal = Decimal("0.0")  # 0 to 1, team A fatigue
    fatigue_team_b: Decimal = Decimal("0.0")  # 0 to 1, team B fatigue
    wind_factor: Optional[Decimal] = None     # 0 to 2, wind impact
    
    def get_serving_team(self) -> TeamSide:
        """Get the currently serving team (always team_a)."""
        return TeamSide.TEAM_A
    
    def get_receiving_team(self) -> TeamSide:
        """Get the currently receiving team (always team_b)."""
        return TeamSide.TEAM_B
    
    def get_current_team_context(self) -> Tuple[TeamSide, str]:
        """Get the team that should be acting based on current state."""
        if self.current_state.value.startswith('s_'):
            return TeamSide.TEAM_A, "serving"
        elif self.current_state.value.startswith('r_'):
            return TeamSide.TEAM_B, "receiving"
        else:
            return TeamSide.TEAM_A, "neutral"
    
    def increment_rally_length(self) -> None:
        """Increment the rally length counter."""
        self.rally_length += 1
    
    def update_state(self, new_state: RallyState) -> None:
        """Update the current state and increment rally length."""
        self.current_state = new_state
        self.increment_rally_length()


# State categorization for easy lookup
TERMINAL_STATES = {
    RallyState.S_SERVE_ACE,
    RallyState.S_SERVE_ERROR,
    RallyState.R_RECEPTION_ERROR,
    RallyState.R_SET_ERROR,
    RallyState.R_ATTACK_KILL,
    RallyState.R_ATTACK_ERROR,
    RallyState.S_DIG_ERROR,
    RallyState.S_BLOCK_KILL,
    RallyState.S_BLOCK_ERROR,
    RallyState.S_SET_ERROR,
    RallyState.S_ATTACK_KILL,
    RallyState.S_ATTACK_ERROR,
    RallyState.R_DIG_ERROR,
    RallyState.R_BLOCK_KILL,
    RallyState.R_BLOCK_ERROR,
    RallyState.TERMINAL_SERVING_TEAM_WINS,
    RallyState.TERMINAL_RECEIVING_TEAM_WINS
}

# Continuation states are dynamically calculated as all states minus terminal states
def get_continuation_states() -> set:
    """Get all continuation states (non-terminal states)."""
    all_states = set(RallyState)
    return all_states - TERMINAL_STATES

# Valid state transitions mapping with team alternation
VALID_TRANSITIONS: Dict[RallyState, List[RallyState]] = {
    # Serving team starts
    RallyState.S_SERVE_READY: [
        RallyState.S_SERVE_ACE,                    # Point for serving team
        RallyState.S_SERVE_ERROR,                  # Point for receiving team
        RallyState.S_SERVE_IN_PLAY                 # Ball in play
    ],
    
    # Serve in play -> receiving team reception
    RallyState.S_SERVE_IN_PLAY: [
        RallyState.R_RECEPTION_PERFECT,            # Perfect pass
        RallyState.R_RECEPTION_GOOD,               # Good pass
        RallyState.R_RECEPTION_POOR,               # Poor pass
        RallyState.R_RECEPTION_ERROR               # Reception error
    ],
    
    # Receiving team reception -> receiving team set
    RallyState.R_RECEPTION_PERFECT: [
        RallyState.R_SET_PERFECT,                  # Perfect set
        RallyState.R_SET_GOOD,                     # Good set
        RallyState.R_SET_ERROR                     # Set error
    ],
    
    RallyState.R_RECEPTION_GOOD: [
        RallyState.R_SET_PERFECT,                  # Perfect set
        RallyState.R_SET_GOOD,                     # Good set
        RallyState.R_SET_POOR,                     # Poor set
        RallyState.R_SET_ERROR                     # Set error
    ],
    
    RallyState.R_RECEPTION_POOR: [
        RallyState.R_SET_POOR,                     # Poor set
        RallyState.R_SET_ERROR,                    # Set error
        RallyState.R_ATTACK_ERROR                  # Emergency attack error
    ],
    
    # Receiving team set -> receiving team attack
    RallyState.R_SET_PERFECT: [
        RallyState.R_ATTACK_KILL,                  # Kill attack
        RallyState.R_ATTACK_IN_PLAY,               # Attack in play
        RallyState.R_ATTACK_ERROR,                 # Attack error
        RallyState.R_ATTACK_BLOCKED                # Attack blocked
    ],
    
    RallyState.R_SET_GOOD: [
        RallyState.R_ATTACK_KILL,                  # Kill attack
        RallyState.R_ATTACK_IN_PLAY,               # Attack in play
        RallyState.R_ATTACK_ERROR,                 # Attack error
        RallyState.R_ATTACK_BLOCKED                # Attack blocked
    ],
    
    RallyState.R_SET_POOR: [
        RallyState.R_ATTACK_IN_PLAY,               # Attack in play
        RallyState.R_ATTACK_ERROR,                 # Attack error
        RallyState.R_ATTACK_BLOCKED                # Attack blocked
    ],
    
    # Receiving team attack -> serving team defense
    RallyState.R_ATTACK_IN_PLAY: [
        RallyState.S_DIG_PERFECT,                  # Perfect dig
        RallyState.S_DIG_GOOD,                     # Good dig
        RallyState.S_DIG_POOR,                     # Poor dig
        RallyState.S_DIG_ERROR                     # Dig error
    ],
    
    # Receiving team attack blocked -> serving team block
    RallyState.R_ATTACK_BLOCKED: [
        RallyState.S_BLOCK_KILL,                   # Block kill
        RallyState.S_BLOCK_CONTROLLED,             # Controlled block
        RallyState.S_BLOCK_TOUCH,                  # Block touch
        RallyState.S_BLOCK_ERROR                   # Block error
    ],
    
    # Serving team dig -> serving team transition
    RallyState.S_DIG_PERFECT: [
        RallyState.S_TRANSITION_SET                # Perfect dig leads to set
    ],
    
    RallyState.S_DIG_GOOD: [
        RallyState.S_TRANSITION_SET,               # Good dig to set
        RallyState.S_TRANSITION_ATTACK             # Good dig to attack
    ],
    
    RallyState.S_DIG_POOR: [
        RallyState.S_TRANSITION_ATTACK,            # Emergency attack
        RallyState.S_TRANSITION_SET,               # Poor set attempt
        RallyState.S_ATTACK_ERROR                  # Direct error
    ],
    
    # Serving team block controlled -> serving team transition
    RallyState.S_BLOCK_CONTROLLED: [
        RallyState.S_TRANSITION_SET                # Controlled block to set
    ],
    
    # Serving team block touch -> serving team dig
    RallyState.S_BLOCK_TOUCH: [
        RallyState.S_DIG_PERFECT,                  # Perfect dig after touch
        RallyState.S_DIG_GOOD,                     # Good dig after touch
        RallyState.S_DIG_POOR,                     # Poor dig after touch
        RallyState.S_DIG_ERROR                     # Dig error after touch
    ],
    
    # Serving team transition -> serving team set/attack
    RallyState.S_TRANSITION_SET: [
        RallyState.S_SET_PERFECT,                  # Perfect set
        RallyState.S_SET_GOOD,                     # Good set
        RallyState.S_SET_POOR,                     # Poor set
        RallyState.S_SET_ERROR                     # Set error
    ],
    
    RallyState.S_TRANSITION_ATTACK: [
        RallyState.S_ATTACK_KILL,                  # Kill attack
        RallyState.S_ATTACK_IN_PLAY,               # Attack in play
        RallyState.S_ATTACK_ERROR,                 # Attack error
        RallyState.S_ATTACK_BLOCKED                # Attack blocked
    ],
    
    # Serving team set -> serving team attack
    RallyState.S_SET_PERFECT: [
        RallyState.S_ATTACK_KILL,                  # Kill attack
        RallyState.S_ATTACK_IN_PLAY,               # Attack in play
        RallyState.S_ATTACK_ERROR,                 # Attack error
        RallyState.S_ATTACK_BLOCKED                # Attack blocked
    ],
    
    RallyState.S_SET_GOOD: [
        RallyState.S_ATTACK_KILL,                  # Kill attack
        RallyState.S_ATTACK_IN_PLAY,               # Attack in play
        RallyState.S_ATTACK_ERROR,                 # Attack error
        RallyState.S_ATTACK_BLOCKED                # Attack blocked
    ],
    
    RallyState.S_SET_POOR: [
        RallyState.S_ATTACK_IN_PLAY,               # Attack in play
        RallyState.S_ATTACK_ERROR,                 # Attack error
        RallyState.S_ATTACK_BLOCKED                # Attack blocked
    ],
    
    # Serving team attack -> receiving team defense
    RallyState.S_ATTACK_IN_PLAY: [
        RallyState.R_DIG_PERFECT,                  # Perfect dig
        RallyState.R_DIG_GOOD,                     # Good dig
        RallyState.R_DIG_POOR,                     # Poor dig
        RallyState.R_DIG_ERROR                     # Dig error
    ],
    
    # Serving team attack blocked -> receiving team block
    RallyState.S_ATTACK_BLOCKED: [
        RallyState.R_BLOCK_KILL,                   # Block kill
        RallyState.R_BLOCK_CONTROLLED,             # Controlled block
        RallyState.R_BLOCK_TOUCH,                  # Block touch
        RallyState.R_BLOCK_ERROR                   # Block error
    ],
    
    # Receiving team dig -> receiving team transition
    RallyState.R_DIG_PERFECT: [
        RallyState.R_TRANSITION_SET                # Perfect dig leads to set
    ],
    
    RallyState.R_DIG_GOOD: [
        RallyState.R_TRANSITION_SET,               # Good dig to set
        RallyState.R_TRANSITION_ATTACK             # Good dig to attack
    ],
    
    RallyState.R_DIG_POOR: [
        RallyState.R_TRANSITION_ATTACK,            # Emergency attack
        RallyState.R_TRANSITION_SET,               # Poor set attempt
        RallyState.R_ATTACK_ERROR                  # Direct error
    ],
    
    # Receiving team block controlled -> receiving team transition
    RallyState.R_BLOCK_CONTROLLED: [
        RallyState.R_TRANSITION_SET                # Controlled block to set
    ],
    
    # Receiving team block touch -> receiving team dig
    RallyState.R_BLOCK_TOUCH: [
        RallyState.R_DIG_PERFECT,                  # Perfect dig after touch
        RallyState.R_DIG_GOOD,                     # Good dig after touch
        RallyState.R_DIG_POOR,                     # Poor dig after touch
        RallyState.R_DIG_ERROR                     # Dig error after touch
    ],
    
    # Receiving team transition -> receiving team set/attack (back to original flow)
    RallyState.R_TRANSITION_SET: [
        RallyState.R_SET_PERFECT,                  # Perfect set
        RallyState.R_SET_GOOD,                     # Good set
        RallyState.R_SET_POOR,                     # Poor set
        RallyState.R_SET_ERROR                     # Set error
    ],
    
    RallyState.R_TRANSITION_ATTACK: [
        RallyState.R_ATTACK_KILL,                  # Kill attack
        RallyState.R_ATTACK_IN_PLAY,               # Attack in play
        RallyState.R_ATTACK_ERROR,                 # Attack error
        RallyState.R_ATTACK_BLOCKED                # Attack blocked
    ]
}


def is_terminal_state(state: RallyState) -> bool:
    """Check if a state is terminal (ends the rally).
    
    Args:
        state: The rally state to check
        
    Returns:
        True if the state ends the rally, False otherwise
    """
    return state in TERMINAL_STATES


def is_continuation_state(state: RallyState) -> bool:
    """Check if a state continues the rally.
    
    Args:
        state: The rally state to check
        
    Returns:
        True if the state continues the rally, False otherwise
    """
    return not is_terminal_state(state)


def get_valid_next_states(current_state: RallyState) -> List[RallyState]:
    """Get list of valid next states from current state.
    
    Args:
        current_state: The current rally state
        
    Returns:
        List of valid next states, empty list if no valid transitions
    """
    return VALID_TRANSITIONS.get(current_state, [])


def get_acting_team(state: RallyState) -> str:
    """Get which team is acting in the given state.
    
    Args:
        state: The rally state
        
    Returns:
        'serving' if serving team acts, 'receiving' if receiving team acts,
        'terminal' if rally is over
    """
    if state.value.startswith('s_'):
        return 'serving'
    elif state.value.startswith('r_'):
        return 'receiving'
    else:
        return 'terminal'


def validate_state_transition(from_state: RallyState, to_state: RallyState) -> bool:
    """Validate if a state transition is allowed.
    
    Args:
        from_state: The starting state
        to_state: The destination state
        
    Returns:
        True if transition is valid, False otherwise
    """
    valid_states = get_valid_next_states(from_state)
    return to_state in valid_states


# Example usage and testing
if __name__ == "__main__":
    # Create a sample rally context for single point simulation
    context = RallyContext(
        current_state=RallyState.S_SERVE_READY,
        rally_length=0,
        momentum=Decimal("-0.2"),
        pressure_level=Decimal("0.8"),
        fatigue_team_a=Decimal("0.1"),
        fatigue_team_b=Decimal("0.3")
    )
    
    print("Beach Volleyball Single Point Simulation")
    print("=" * 45)
    print(f"Current state: {context.current_state}")
    print(f"Serving team: {context.get_serving_team()}")
    print(f"Rally length: {context.rally_length}")
    print(f"Momentum: {context.momentum}")
    print(f"Pressure level: {context.pressure_level}")
    print(f"Acting team: {get_acting_team(context.current_state)}")
    
    # Show valid transitions
    next_states = get_valid_next_states(context.current_state)
    print(f"\nValid next states from {context.current_state}:")
    for state in next_states:
        print(f"  -> {state} (team: {get_acting_team(state)})")
    
    # Show continuation states count
    continuation_states = get_continuation_states()
    print(f"\nTotal states: {len(list(RallyState))}")
    print(f"Terminal states: {len(TERMINAL_STATES)}")
    print(f"Continuation states: {len(continuation_states)}")
    
    # Test state transition validation
    print(f"\nValidation tests:")
    print(f"S_SERVE_READY -> S_SERVE_IN_PLAY: {validate_state_transition(RallyState.S_SERVE_READY, RallyState.S_SERVE_IN_PLAY)}")
    print(f"S_SERVE_IN_PLAY -> R_RECEPTION_GOOD: {validate_state_transition(RallyState.S_SERVE_IN_PLAY, RallyState.R_RECEPTION_GOOD)}")
    print(f"R_ATTACK_IN_PLAY -> S_DIG_GOOD: {validate_state_transition(RallyState.R_ATTACK_IN_PLAY, RallyState.S_DIG_GOOD)}")
    print(f"Invalid transition test: {validate_state_transition(RallyState.S_SERVE_READY, RallyState.R_DIG_GOOD)}")
    
    # Test continuation state logic
    print(f"\nContinuation state tests:")
    print(f"S_SERVE_READY is continuation: {is_continuation_state(RallyState.S_SERVE_READY)}")
    print(f"S_SERVE_ACE is continuation: {is_continuation_state(RallyState.S_SERVE_ACE)}")
    print(f"R_RECEPTION_GOOD is continuation: {is_continuation_state(RallyState.R_RECEPTION_GOOD)}")
    print(f"R_ATTACK_KILL is continuation: {is_continuation_state(RallyState.R_ATTACK_KILL)}")
    
    # Test context update methods
    print(f"\nContext update tests:")
    print(f"Rally length before: {context.rally_length}")
    context.update_state(RallyState.S_SERVE_IN_PLAY)
    print(f"New state: {context.current_state}")
    print(f"Rally length after: {context.rally_length}")
    
    # Test StateTransition creation
    print(f"\nStateTransition creation test:")
    try:
        transition = create_state_transition(
            from_state=RallyState.S_SERVE_READY,
            to_state=RallyState.S_SERVE_IN_PLAY,
            probability=Decimal("0.75"),
            action_type=ActionType.SERVE,
            performing_team=TeamSide.TEAM_A,
            description="Serve in play"
        )
        print(f"Created transition: {transition.from_state} -> {transition.to_state} (p={transition.probability})")
    except ValueError as e:
        print(f"Validation error: {e}")
    
    # Test invalid probability
    try:
        invalid_transition = create_state_transition(
            from_state=RallyState.S_SERVE_READY,
            to_state=RallyState.S_SERVE_IN_PLAY,
            probability=Decimal("1.5"),  # Invalid probability
            action_type=ActionType.SERVE,
            performing_team=TeamSide.TEAM_A
        )
    except ValueError as e:
        print(f"Expected validation error caught: {e}")
    
    print("\nSingle point state machine loaded successfully!")

